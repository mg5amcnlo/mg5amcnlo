      SUBROUTINE SUDAKOV_WRAPPER(P)
      IMPLICIT NONE
      INCLUDE 'nexternal.inc'
      INCLUDE 'born_nhel.inc'
      DOUBLE PRECISION P(0:3, NEXTERNAL-1)

      INTEGER I,J
      INTEGER IHEL
      INTEGER     NCOMB
      PARAMETER ( NCOMB=  16 )
      INTEGER NHEL(NEXTERNAL-1,NCOMB)
      DATA (NHEL(I,   1),I=1,4) /-1, 1,-1, 1/
      DATA (NHEL(I,   2),I=1,4) /-1, 1,-1,-1/
      DATA (NHEL(I,   3),I=1,4) /-1, 1, 1, 1/
      DATA (NHEL(I,   4),I=1,4) /-1, 1, 1,-1/
      DATA (NHEL(I,   5),I=1,4) /-1,-1,-1, 1/
      DATA (NHEL(I,   6),I=1,4) /-1,-1,-1,-1/
      DATA (NHEL(I,   7),I=1,4) /-1,-1, 1, 1/
      DATA (NHEL(I,   8),I=1,4) /-1,-1, 1,-1/
      DATA (NHEL(I,   9),I=1,4) / 1, 1,-1, 1/
      DATA (NHEL(I,  10),I=1,4) / 1, 1,-1,-1/
      DATA (NHEL(I,  11),I=1,4) / 1, 1, 1, 1/
      DATA (NHEL(I,  12),I=1,4) / 1, 1, 1,-1/
      DATA (NHEL(I,  13),I=1,4) / 1,-1,-1, 1/
      DATA (NHEL(I,  14),I=1,4) / 1,-1,-1,-1/
      DATA (NHEL(I,  15),I=1,4) / 1,-1, 1, 1/
      DATA (NHEL(I,  16),I=1,4) / 1,-1, 1,-1/
      DOUBLE COMPLEX ANS_SUMMED

      INCLUDE 'orders.inc'
      DOUBLE COMPLEX AMP_SPLIT_EWSUD(AMP_SPLIT_SIZE)
      COMMON /TO_AMP_SPLIT_EWSUD/ AMP_SPLIT_EWSUD
      DOUBLE COMPLEX AMP_SPLIT_EWSUD_LO2(AMP_SPLIT_SIZE)
      COMMON /TO_AMP_SPLIT_EWSUD_LO2/ AMP_SPLIT_EWSUD_LO2

      DOUBLE COMPLEX AMP_SPLIT_EWSUD_LSC(AMP_SPLIT_SIZE)
      COMMON /TO_AMP_EWSUD_LSC/AMP_SPLIT_EWSUD_LSC
      DOUBLE COMPLEX AMP_SPLIT_EWSUD_SSC(AMP_SPLIT_SIZE)
      COMMON /TO_AMP_EWSUD_SSC/AMP_SPLIT_EWSUD_SSC
      DOUBLE COMPLEX AMP_SPLIT_EWSUD_XXC(AMP_SPLIT_SIZE)
      COMMON /TO_AMP_EWSUD_XXC/AMP_SPLIT_EWSUD_XXC
      DOUBLE COMPLEX AMP_SPLIT_EWSUD_PAR(AMP_SPLIT_SIZE)
      COMMON /TO_AMP_EWSUD_PAR/AMP_SPLIT_EWSUD_PAR
      DOUBLE COMPLEX AMP_SPLIT_EWSUD_QCD(AMP_SPLIT_SIZE)
      COMMON /TO_AMP_EWSUD_QCD/AMP_SPLIT_EWSUD_QCD
      DOUBLE COMPLEX AMP_SPLIT_BORN_ONEHEL(AMP_SPLIT_SIZE)
      COMMON /TO_AMP_BORN_ONEHEL/AMP_SPLIT_BORN_ONEHEL
      DOUBLE COMPLEX AMP_SPLIT_EWSUD_PARQCD(AMP_SPLIT_SIZE)
      COMMON /TO_AMP_EWSUD_PARQCD/AMP_SPLIT_EWSUD_PARQCD

      INTEGER IFLIST(NEXTERNAL-1), PDGLIST(NEXTERNAL-1),
     $  PDGLIST_OTH(NEXTERNAL-1)

      DOUBLE PRECISION INVARIANTS(NEXTERNAL-1, NEXTERNAL-1)

      DOUBLE COMPLEX GET_LSC_DIAG, GET_LSC_NONDIAG
      EXTERNAL GET_LSC_DIAG, GET_LSC_NONDIAG
      DOUBLE COMPLEX GET_SSC_N_DIAG, GET_SSC_N_NONDIAG_1,
     $  GET_SSC_N_NONDIAG_2, GET_SSC_C
      EXTERNAL GET_SSC_N_DIAG, GET_SSC_N_NONDIAG_1,
     $  GET_SSC_N_NONDIAG_2, GET_SSC_C
      DOUBLE COMPLEX GET_XXC_DIAG, GET_XXC_NONDIAG
      EXTERNAL GET_XXC_DIAG, GET_XXC_NONDIAG
      DOUBLE COMPLEX GET_QCD_LO2
      EXTERNAL GET_QCD_LO2

      LOGICAL CALCULATEDBORN
      COMMON/CCALCULATEDBORN/CALCULATEDBORN

      INTEGER EWSUD_HELSELECT
      COMMON/TO_EWSUD_HELSELECT/EWSUD_HELSELECT

      DOUBLE PRECISION COMPENSATE_IDENTICAL_FACTOR
      EXTERNAL COMPENSATE_IDENTICAL_FACTOR
      DOUBLE PRECISION COMP_IDFAC

      LOGICAL GOOD_HEL(NCOMB), FIRSTTIME_HEL(NCOMB)
      DATA GOOD_HEL  /NCOMB*.TRUE./
      DATA FIRSTTIME_HEL  /NCOMB*.TRUE./
      INTEGER IAMP
      LOGICAL SUD_FILTER_HEL
      COMMON /TO_FILTER_HEL/ SUD_FILTER_HEL
C     stuff for the MC over helicities
      LOGICAL SUD_MC_HEL
      COMMON /TO_MC_HEL/ SUD_MC_HEL
      INTEGER IGOOD_HEL(NCOMB), HEL(0:NCOMB)
      DATA IGOOD_HEL  /NCOMB * 0/
      LOGICAL FIRSTTIME
      DATA FIRSTTIME /.TRUE./
      INTEGER HEL_MIN, HEL_MAX, HEL_PICK
      DOUBLE PRECISION VOLH

      INCLUDE 'ewsudakov_haslo.inc'


      AMP_SPLIT_EWSUD_LSC(:) = DCMPLX(0D0,0D0)
      AMP_SPLIT_EWSUD_SSC(:) = DCMPLX(0D0,0D0)
      AMP_SPLIT_EWSUD_XXC(:) = DCMPLX(0D0,0D0)
      AMP_SPLIT_EWSUD_PAR(:) = DCMPLX(0D0,0D0)

      AMP_SPLIT_EWSUD_QCD(:) = DCMPLX(0D0,0D0)
      AMP_SPLIT_EWSUD_PARQCD(:) = DCMPLX(0D0,0D0)


      IFLIST = (/-1,-1,1,1/)

      CALL SDK_GET_INVARIANTS(P, IFLIST, INVARIANTS)

      IF (FIRSTTIME.OR..NOT.SUD_MC_HEL) THEN
        HEL_MIN = 1
        HEL_MAX = NCOMB
        HEL(:)=0
        VOLH=1D0
        FIRSTTIME=.FALSE.
      ELSE
        CALL PICKHELICITYMC(P,IGOOD_HEL,HEL,HEL_PICK,VOLH)
        HEL_MIN = HEL(HEL_PICK)
        HEL_MAX = HEL_MIN
      ENDIF

      CALCULATEDBORN=.FALSE.

C     Main loop over the helicities
      DO IHEL=HEL_MIN, HEL_MAX
C       if an helicity is selected, then filter it
        IF (EWSUD_HELSELECT.NE.0.AND.EWSUD_HELSELECT.NE.IHEL) CYCLE

        IF (.NOT.GOOD_HEL(IHEL).AND.SUD_FILTER_HEL) CYCLE

C       call the born amplitude and store the result
        CALL SBORN_ONEHEL(P,NHEL(1,IHEL),IHEL,ANS_SUMMED)
        AMP_SPLIT_BORN_ONEHEL(:) = AMP_SPLIT_EWSUD(:)

        IF (FIRSTTIME_HEL(IHEL)) THEN
          GOOD_HEL(IHEL) = .FALSE.
          DO IAMP = 1, AMP_SPLIT_SIZE
            GOOD_HEL(IHEL) = GOOD_HEL(IHEL)
     $       .OR.AMP_SPLIT_BORN_ONEHEL(IAMP)
     $       .NE.0D0.OR.AMP_SPLIT_EWSUD_LO2(IAMP).NE.0D0
          ENDDO

          IF (GOOD_HEL(IHEL)) THEN
            HEL(0) = HEL(0)+1
            HEL(HEL(0)) = IHEL
            IGOOD_HEL(HEL(0)) = 1
          ENDIF
            !write(*,*) 'EW SUDAKOV WRAPPER HEL FILTER', ihel, nhel(:,ihel), good_hel(ihel)
          FIRSTTIME_HEL(IHEL) = .FALSE.
        ENDIF

C       call the amplitudes with the goldstones for the
C        longitudinally-polarised legs and the born for all-transverse
        CALL SBORN_ONEHEL(P,NHEL(1,IHEL),IHEL,ANS_SUMMED)
        COMP_IDFAC = 1D0
        PDGLIST = (/-4,4,6,-6/)
C       the LSC term (diagonal)
        AMP_SPLIT_EWSUD_LSC(:) = AMP_SPLIT_EWSUD_LSC(:)
     $   +AMP_SPLIT_EWSUD(:)*GET_LSC_DIAG(PDGLIST,NHEL(1,IHEL),IFLIST
     $   ,INVARIANTS)*COMP_IDFAC
C       the SSC term (neutral/diagonal)
        AMP_SPLIT_EWSUD_SSC(:) = AMP_SPLIT_EWSUD_SSC(:)
     $   +AMP_SPLIT_EWSUD(:)*GET_SSC_N_DIAG(PDGLIST,NHEL(1,IHEL)
     $   ,IFLIST,INVARIANTS)*COMP_IDFAC
C       the C term (diagonal)
        AMP_SPLIT_EWSUD_XXC(:) = AMP_SPLIT_EWSUD_XXC(:)
     $   +AMP_SPLIT_EWSUD(:)*GET_XXC_DIAG(PDGLIST,NHEL(1,IHEL),IFLIST
     $   ,INVARIANTS)*COMP_IDFAC
C       the parameter renormalisation
        CALL PAR_REN_SBORN_ONEHEL(P,NHEL(1,IHEL),IHEL,INVARIANTS)
        AMP_SPLIT_EWSUD_PAR(:) = AMP_SPLIT_EWSUD_PAR(:)
     $   +AMP_SPLIT_EWSUD(:)*COMP_IDFAC
C       the SSC terms (charged)
        CALL EWSDK_ME_1(P,NHEL(1,IHEL),ANS_SUMMED)
        PDGLIST_OTH = (/-3,3,6,-6/)
        AMP_SPLIT_EWSUD_SSC(:) = AMP_SPLIT_EWSUD_SSC(:)
     $   +AMP_SPLIT_EWSUD(:)*GET_SSC_C(1,2,PDGLIST,-3,3,NHEL(1,IHEL)
     $   ,IFLIST,INVARIANTS)*COMP_IDFAC
        CALL EWSDK_ME_2(P,NHEL(1,IHEL),ANS_SUMMED)
        PDGLIST_OTH = (/-4,4,5,-5/)
        AMP_SPLIT_EWSUD_SSC(:) = AMP_SPLIT_EWSUD_SSC(:)
     $   +AMP_SPLIT_EWSUD(:)*GET_SSC_C(3,4,PDGLIST,5,-5,NHEL(1,IHEL)
     $   ,IFLIST,INVARIANTS)*COMP_IDFAC

      ENDDO

      AMP_SPLIT_EWSUD_LSC(:) = AMP_SPLIT_EWSUD_LSC(:)/VOLH
      AMP_SPLIT_EWSUD_SSC(:) = AMP_SPLIT_EWSUD_SSC(:)/VOLH
      AMP_SPLIT_EWSUD_XXC(:) = AMP_SPLIT_EWSUD_XXC(:)/VOLH
      AMP_SPLIT_EWSUD_PAR(:) = AMP_SPLIT_EWSUD_PAR(:)/VOLH

      AMP_SPLIT_EWSUD_QCD(:) = AMP_SPLIT_EWSUD_QCD(:)/VOLH
      AMP_SPLIT_EWSUD_PARQCD(:) = AMP_SPLIT_EWSUD_PAR(:)

      DO IAMP = 1, AMP_SPLIT_SIZE

        IF (HAS_LO1) THEN
          IF(IAMP.NE.LO1_POS) AMP_SPLIT_EWSUD_PAR(IAMP)=(0D0,0D0)
        ELSE
          AMP_SPLIT_EWSUD_PAR(IAMP)=(0D0,0D0)
        ENDIF

        IF (HAS_LO2) THEN
          IF(IAMP.NE.LO2_POS) AMP_SPLIT_EWSUD_PARQCD(IAMP)=(0D0,0D0)
        ELSE
          AMP_SPLIT_EWSUD_PARQCD(IAMP)=(0D0,0D0)
        ENDIF

      ENDDO



      CALCULATEDBORN=.FALSE.

      RETURN
      END





      INTEGER FUNCTION SDK_GET_NCOMB()
      IMPLICIT NONE
      INTEGER     NCOMB
      PARAMETER ( NCOMB=  16 )

      SDK_GET_NCOMB = NCOMB

      RETURN
      END


      SUBROUTINE SDK_GET_HELS(IHEL, HELS)
      IMPLICIT NONE
      INCLUDE 'nexternal.inc'
      INTEGER IHEL, I
      INTEGER HELS(NEXTERNAL-1)
      INTEGER     NCOMB
      PARAMETER ( NCOMB=  16 )
      INTEGER NHEL(NEXTERNAL-1,NCOMB)
      DATA (NHEL(I,   1),I=1,4) /-1, 1,-1, 1/
      DATA (NHEL(I,   2),I=1,4) /-1, 1,-1,-1/
      DATA (NHEL(I,   3),I=1,4) /-1, 1, 1, 1/
      DATA (NHEL(I,   4),I=1,4) /-1, 1, 1,-1/
      DATA (NHEL(I,   5),I=1,4) /-1,-1,-1, 1/
      DATA (NHEL(I,   6),I=1,4) /-1,-1,-1,-1/
      DATA (NHEL(I,   7),I=1,4) /-1,-1, 1, 1/
      DATA (NHEL(I,   8),I=1,4) /-1,-1, 1,-1/
      DATA (NHEL(I,   9),I=1,4) / 1, 1,-1, 1/
      DATA (NHEL(I,  10),I=1,4) / 1, 1,-1,-1/
      DATA (NHEL(I,  11),I=1,4) / 1, 1, 1, 1/
      DATA (NHEL(I,  12),I=1,4) / 1, 1, 1,-1/
      DATA (NHEL(I,  13),I=1,4) / 1,-1,-1, 1/
      DATA (NHEL(I,  14),I=1,4) / 1,-1,-1,-1/
      DATA (NHEL(I,  15),I=1,4) / 1,-1, 1, 1/
      DATA (NHEL(I,  16),I=1,4) / 1,-1, 1,-1/

      HELS(:) = NHEL(:, IHEL)

      RETURN
      END


      DOUBLE PRECISION FUNCTION COMPENSATE_IDENTICAL_FACTOR(IGOLD_ME)
C     provides the multiplicative factor for the result of the
C     sudakov MEs so that they have the same identical-particle
C     factor as the Born in the specific FKS configuration
      IMPLICIT NONE
      INTEGER IGOLD_ME
C     
      INTEGER SDK_IDENT_GOLDSTONE(1)
      DATA SDK_IDENT_GOLDSTONE / 0 /
C     
      INTEGER NFKSPROCESS
      COMMON/C_NFKSPROCESS/NFKSPROCESS
      INTEGER IDEN_VALUES(1)
      DATA IDEN_VALUES / 36 /
      INTEGER BORNSPINCOL
      DATA BORNSPINCOL / 36 /

      COMPENSATE_IDENTICAL_FACTOR = DBLE(SDK_IDENT_GOLDSTONE(IGOLD_ME))
     $ /DBLE(IDEN_VALUES(NFKSPROCESS)/BORNSPINCOL)

      RETURN
      END


